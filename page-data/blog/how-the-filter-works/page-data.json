{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-js",
    "path": "/blog/how-the-filter-works/",
    "result": {"data":{"markdownRemark":{"frontmatter":{"author":"Not Toby Bridle","authorPicture":"https://cdn.ebaumsworld.com/2020/01/13/021054/86172703/lego-star-wars-profile-4.jpg","date":"December 27 2021","title":"How does the Filtering Work?","description":"An Article explaining how the filter system would be used.","articleThumbnail":"https://img.icons8.com/color/344/filter-and-sort.png","squishThumbnail":false},"html":"<h1>How the Filter System currently works</h1>\n<p>At the moment, since this is just a static page, GraphQL retrieves a list of articles &#x26; their metadata.\nThis metadata contains lots of useful information, but what we use for the filtering is <code>rank</code> &#x26; <code>following</code>. The <code>rank</code> property shows how high on the <strong>Popular</strong> filter the article should be, and <code>following</code> just indicates that the article should be on the <strong>Following</strong> filter.</p>\n<h1>How this could be done using a Server</h1>\n<p>We could use a similar concept as already shown; however, rather than manually needing to update the frontmatter of each blog page - we could use GraphQL <a href=\"https://graphql.org/learn/queries/\"><strong>mutations</strong></a>. Mutations are used to update the value of a field on the server. We could combine a <code>useEffect</code> and a mutation regarding the change of a field named <code>hits</code>.\nThen, when we are rendering the articles, we can sort by <code>hits</code> in descending order for the <strong>Popular</strong> filter.</p>"}},"pageContext":{"id":"1ef27f76-b8d6-5b1a-97bd-e023c5002c5c","frontmatter__slug":"/blog/how-the-filter-works","__params":{"frontmatter__slug":"blog"}}},
    "staticQueryHashes": []}